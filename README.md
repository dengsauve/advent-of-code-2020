# Advent of Code - 2020
Gather 'round, gather 'round, it is once again time to celebrate the approaching Christmas Holiday in the most time honored and cherished way. Every night at midnight<sup>1</sup>, a new 2 part programming challenge appears on the advent calenar. As is tradition, I'll be solving these puzzles using [Ruby](https://www.ruby-lang.org/en/), and if you look at my code, you'll have to agree you can do pretty neat things with Ruby<sup>2</sup>.


## Daily Log
**Day-01**
Easy peasy, brute forcing array of ints to find some combos. Might try to refactor into a recursive function.

**Day-02**
Easy, a little ruby-fu with the password strings and boom, done.

**Day-03**
First read through seemed harder than it was, second read through realized you're only counting trees at whole integer locations.

**Day-04**
Little longer due to the amount of validation, but I got both parts right on the first try, which felt great!

**Day-05**
I messed up by not adding the column and instead ended up multiplying all three at first. Took me 15 minutes of debugging to realize my mistake, and by then any chance of top 100 was long gone. Still took me less than 30 minutes even with the hair pulling 15 of figuring out why something was amiss.

**Day-06**
Array uniq counts and merging then checking for counts. Easy enough to solve, late start tonight.

**Day-07**
I don't know what I was thinking, but I tried and OO the first night. Came back w/fresh eyes the next day and binned the whole affair. Solved w/procedural loops. Recursive would have been nice, but ü§∑‚Äç‚ôÇÔ∏è

**Day-08**
I forgot to reset the @accumulator variable when trying jpm/nop swapping, that set me back 5 minutes at least on the 2nd half.

**Day-09**
First part, easy peasy. Second part was a little more tedious, mostly because I thought about recursing the problem the wrong way.

**Day-10**
First part was very straightforward, the second part I actually couldn't wrap my mind around how to do this programmatically.
I'm not ashamed to say that I lifted a solution from reddit's megathread.
On that note, I resolve to teach myself more about Dynamic Programming and how it applies to this puzzle.

**Day-11**


## Footnotes

<sup>1</sup>Eastern Standard Time üòâ

<sup>2</sup>Why Ruby? Because it [is magical | is chainable | is intuitive | comes with an XOR operator | is ‚àû better than PHP or Python or Java or JS | is totally rubular üèÑ‚Äç‚ôÇÔ∏è], and the syntax is similar to [Crystal](https://crystal-lang.org/) which has mush faster performance due to being compiled (though it should be noted, Ruby != Crystal).
